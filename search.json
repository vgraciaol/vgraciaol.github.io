[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About me",
    "section": "",
    "text": "I am a PhD Health Policy student in the Department of Health Policy at Stanford University in the Decision Science track and a Fulbright scholar. Prior to starting my PhD at Stanford in 2022, I worked as a research assistant at the Center for Research and Teaching in Economics (CIDE) in Mexico.\nIn 2020, I joined the Stanford-CIDE COronavirus Simulation MOdel (SC-COSMO) consortium where I worked on high-impact projects to estimate the health effects of non-pharmaceutical interventions to control the spread of the COVID-19 epidemic in Mexico. Additionally, as a member of the Cancer Intervention and Surveillance Modeling Network (CISNET), I worked on a project to model HPV transmission and cervical cancer disease at a state level in the United States."
  },
  {
    "objectID": "rprogramming.html",
    "href": "rprogramming.html",
    "title": "Learning R",
    "section": "",
    "text": "NOTE: The code in this document has been created following the coding recommendations in Alarid-Escudero et al. (2019)."
  },
  {
    "objectID": "rprogramming.html#matrices-and-arrays",
    "href": "rprogramming.html#matrices-and-arrays",
    "title": "Learning R",
    "section": "Matrices and arrays",
    "text": "Matrices and arrays\nA matrix is a powerful tool, featuring a rectangular arrangement of numbers, symbols, or expressions in rows and columns. For example,\n\\[\nA = \\begin{bmatrix}\n1 & 2 \\\\\n7 & 3 \\\\\n4 & 9\n\\end{bmatrix}\n\\]\n\\(A\\) is a matrix with 3 rows and 2 columns, usually said to be a \\(3 \\times 2\\) matrix.\nMatrices are useful for organizing (numeric) data based on individuals (rows) and attributes (columns). For instance, imagine you have the age, sex, and years of schooling for three people:\n\n\n\n\n\nInd\nAge\nMale\nYears of schooling\n\n\n\n\n1\n48\n1\n10\n\n\n2\n34\n0\n9\n\n\n3\n56\n1\n12\n\n\n\n\n\n\n\nThis information can then be represented by a \\(3 \\times 3\\) matrix:\n\\[\n\\begin{bmatrix}\n48 & 1 & 10 \\\\\n34 & 0 & 9 \\\\\n56 & 1 & 12\n\\end{bmatrix}\n\\]\n\nMatrix\nThe matrix() function in R has the following arguments:\n\ndata in a form of a vector,\nnrow number of rows,\nncol number of columns,\nbyrow (logical) default is FALSE meaning that the matrix is filled by columns,\ndimnames a list of two elements containing the row and column names, respectively.\n\nExample 1\nLet’s create a \\(2 \\times 2\\) matrix:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNote how R filled the matrix column-by-column since by default byrow = FALSE.\nExample 2\nWhat happens if you don’t specify the nrow and ncol arguments?\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIf nrow and ncol are not specified default is a single-column matrix.\nExample 3\nLet’s change the byrow argument to TRUE.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNote that the matrix’s first row was filled out before moving on to the next one.\nExample 4\nLet’s create a \\(2 \\times 3\\) matrix whose row and column names are indicated using dimnames.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNote that dimnames must be specified using a list.\nExample 5\nWhat if you don’t have enough data to fill the matrix?\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIf there is insufficient data to fill a matrix as specified by the user, the values will be recycled. This is important to note as it will not give an error, but a warning, and the matrix can still be used in other operations.\nSub-setting\nWe can subset values from a matrix by indicating matrix_name[row,column].\n\nIf the matrix rows and columns have names the names can be used to subset.\nIf you leave the row (column) value blank, it will extract the entire column (row).\n\nExample\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nOperations with matrices\n\nt() transpose of a matrix: switching a matrix’s rows and columns.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\ndiag() extract or replace the diagonal of a matrix, or construct a diagonal matrix. NOTE: Remember that you can always use ?diag to get documentation about the function and its uses.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nEqually sized matrices can be added and subtracted.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nMatrix multiplication %*%: ncol and nrow can be useful functions that check if two matrices can be multiplied.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nsolve() returns the inverse of a square matrix.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nArrays\nMatrices are a special kind of two-dimensional arrays. If you want to create objects with more dimensions, array() is a useful function.\nExample 1\nAn array with 3 rows, 4 columns and 2 layers, filled column-wise.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExample 2\nAdding another layer.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nSub-setting\n\nPlease enable JavaScript to experience the dynamic code cell content on this page."
  },
  {
    "objectID": "rprogramming.html#conditionals-and-loops",
    "href": "rprogramming.html#conditionals-and-loops",
    "title": "Learning R",
    "section": "Conditionals and loops",
    "text": "Conditionals and loops\n\nif-else statement\nAn If-else statement requires a condition that returns TRUE or FALSE.\nBasic structure:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExample 1\nLet’s evaluate a number. If the number is 4, then let’s square it; otherwise, let’s return the same number.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExample 2\nIf-else only works for conditions of length = 1.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExample 3\nYou can use nested if-else if you want to evaluate more than one statement.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExample 4\nThe switch function allows to evaluate an expression (EXPR) and choose from a list of alternatives. The following code is similar to Example 3.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExample 5\nUse the ifelse(test, yes, no) function to test an expression and return the elements in yes or no, depending on whether the test is TRUE or FALSE. The following code is similar to Example 1. This can be useful when managing data.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nfor loops\nBasic structure:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExample 1\nA loop that prints the index of the current loop.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNOTE: as a practice, use names for your loop index that ends with _i, for example, iter_i, year_i, and ind_i; this will allow you to differentiate between the loop index and your other objects.\nExample 2\nLet’s create a matrix whose elements are equal to the multiplication of the row and column numbers (i.e., let \\(m_{i,j}\\) be the element in the \\(i\\)-th row and \\(j\\)-th column of the matrix, then \\(m_{i,j} = i\\times j\\)).\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nwhile loops\nWhen you do not know how often the desired operations should be executed, you can use the while loop.\nBasic structure:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExample 1\nLet’s create a code that calculates the factorial of any number.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page."
  },
  {
    "objectID": "rprogramming.html#writing-functions",
    "href": "rprogramming.html#writing-functions",
    "title": "Learning R",
    "section": "Writing functions",
    "text": "Writing functions\nBasic structure:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExample 1\nA function that simply assigns three different objects.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNote that even if you run the function, trying to get the element aa does not work. This happens because everything that is executed inside a function resides locally in the function. To get the objects you create inside a function, you need to add a return().\nHowever, what happens if you run bn &lt;- dummy1() and then get the object bn?\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNote that a function that does not have a return() technically returns nothing; but it implicitly returns the last line of code.\nExample 2\nBut how many return() can a function have? See the following example of a function with multiple returns.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNote that a function can have multiple return(), however, once it encounters one, it exits.\nExample 3\nA function with arguments.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nDoes a function always require arguments? No, it doesn’t. A list of arguments is not always required to execute a function. So, when is it necessary to add arguments to our functions? We add them when we want to execute a code multiple times using different input values.\nEllipsis ...\nIt allows you to pass additional arguments without having to first define them in the argument list, and these arguments can then be passed to another function call within the body of the code.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page."
  },
  {
    "objectID": "rprogramming.html#markov-models",
    "href": "rprogramming.html#markov-models",
    "title": "Learning R",
    "section": "Markov models",
    "text": "Markov models\nThis section is based on Drabo and Padula (2023) and follows the same example of hepatitis B. The coding sections have been created by me.\n\nIntroduction\n\nModels can be a valuable tool for public health decision-making. They help to extrapolate the long-term effects of observed clinical trials and estimate the distribution of a population into different health states when implementing policy strategies.\nHealth (e.g., life years, quality of life years) and economic (e.g., vaccination costs) outcomes can be estimated for each strategy considered.\nMarkov models represent how individuals in a cohort move between health states based on their probabilities of previous states.\nMarkov assumption: all states are independent of all past states.\n\n\n\nElements\n\nSet of health states that are mutually exclusive (an individual cannot be in both states simultaneously) and exhaustive (includes all possible states).\nTransition matrix that represents the transition of individuals in a cohort between different health states (constant or time-varying).\n\n\\[\nT =\n\\begin{bmatrix}\nq(s_1,s_1) & q(s_1,s_2) & q(s_1,s_3) \\\\\nq(s_2,s_1) & q(s_2,s_2) & q(s_2,s_3)\n\\end{bmatrix}\n\\]\n\n\\(q(s_i,s_j)\\) describes the transition probability from the current state \\(s_i\\) to the transition state \\(s_j\\).\nThe value of each transition probability ranges between 0 and 1.\nEach row must sum to 1 since all states are mutually exclusive.\n\n\nTransitions occur over a period, called cycle \\(t\\).\nThe probability of being in a state \\(S(t)\\) can be denoted as:\n\n\\[\nS(t) = S(0)\\times T^t\n\\]\nwhere, \\(S(0)\\) is the vector of the probabilities of being in each state at the beginning of the simulation, \\(T^t\\) is the product of multiplying \\(t\\) state transition matrices.\n\nSet of rewards or payoffs (e.g., cost of benefits) associated to each state.\nIf an individual is unable to leave a state once they enter it (e.g., dead), that state is considered to be an absorbing state, and any non-absorbing state is called transient.\n\n\n\nExample: hepatitis B vaccine\n\nFive mutually exclusive health states: susceptible (S), infected (I), vaccinated (V), recovered (R), and dead (D).\n\n\n\n\nState transition diagram\n\n\n\nCycle length 1 year.\nTime horizon 59 years.\nModel inputs usually come from published data, clinical trials (e.g., vaccine efficacy), transition probabilities from life tables, expert panels, among others.\n\nThe proportion of susceptible people getting vaccinated each cycle is 0.10.\n70% of susceptible people become infected each year.\n0.0045% of the vaccinated individuals lose protection from the vaccine.\n7 out of 8 people with hepatitis B recover.\nThe probability of death is 0.002 for susceptible, vaccinated, and recovered individuals, and 0.006 for infected individuals.\nSusceptible cohort population.\n\n\n\nSteps into developing a model in R\n\nParameterization of the model.\nWe will create a function that takes the model inputs as arguments and returns a list containing all the model parameters.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nMarkov model function.\nNow that we have a function that collects all the model inputs into a list, let’s create a function that takes the model parameters and returns the distribution of health states at each step.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nSimulation:\nWe run the Markov model with the specific model inputs.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPlot health states\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "About me",
    "section": "",
    "text": "I am a PhD Health Policy student in the Department of Health Policy at Stanford University in the Decision Science track and a Fulbright scholar. Prior to starting my PhD at Stanford in 2022, I worked as a research assistant at the Center for Research and Teaching in Economics (CIDE) in Mexico.\nIn 2020, I joined the Stanford-CIDE COronavirus Simulation MOdel (SC-COSMO) consortium where I worked on high-impact projects to estimate the health effects of non-pharmaceutical interventions to control the spread of the COVID-19 epidemic in Mexico. Additionally, as a member of the Cancer Intervention and Surveillance Modeling Network (CISNET), I worked on a project to model HPV transmission and cervical cancer disease at a state level in the United States."
  }
]